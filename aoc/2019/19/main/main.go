package main

import (
	"fmt"
	"github.com/dragonsinth/learn/aoc/2019/intcode"
	"github.com/dragonsinth/learn/aoc/termbox"
	"os"
)

const prog = `109,424,203,1,21101,11,0,0,1105,1,282,21101,18,0,0,1106,0,259,2102,1,1,221,203,1,21101,0,31,0,1106,0,282,21102,38,1,0,1105,1,259,20101,0,23,2,22101,0,1,3,21101,1,0,1,21101,0,57,0,1105,1,303,2101,0,1,222,20102,1,221,3,21001,221,0,2,21101,0,259,1,21101,80,0,0,1105,1,225,21101,137,0,2,21101,91,0,0,1105,1,303,1202,1,1,223,21001,222,0,4,21102,259,1,3,21101,225,0,2,21102,225,1,1,21101,0,118,0,1106,0,225,20102,1,222,3,21101,0,88,2,21102,133,1,0,1105,1,303,21202,1,-1,1,22001,223,1,1,21101,0,148,0,1106,0,259,1202,1,1,223,20102,1,221,4,20101,0,222,3,21101,24,0,2,1001,132,-2,224,1002,224,2,224,1001,224,3,224,1002,132,-1,132,1,224,132,224,21001,224,1,1,21102,1,195,0,106,0,108,20207,1,223,2,20102,1,23,1,21101,-1,0,3,21101,0,214,0,1105,1,303,22101,1,1,1,204,1,99,0,0,0,0,109,5,2102,1,-4,249,22102,1,-3,1,22102,1,-2,2,22102,1,-1,3,21101,0,250,0,1105,1,225,22102,1,1,-4,109,-5,2106,0,0,109,3,22107,0,-2,-1,21202,-1,2,-1,21201,-1,-1,-1,22202,-1,-2,-2,109,-3,2106,0,0,109,3,21207,-2,0,-1,1206,-1,294,104,0,99,22101,0,-2,-2,109,-3,2105,1,0,109,5,22207,-3,-4,-1,1206,-1,346,22201,-4,-3,-4,21202,-3,-1,-1,22201,-4,-1,2,21202,2,-1,-1,22201,-4,-1,1,22102,1,-2,3,21102,343,1,0,1105,1,303,1105,1,415,22207,-2,-3,-1,1206,-1,387,22201,-3,-2,-3,21202,-2,-1,-1,22201,-3,-1,3,21202,3,-1,-1,22201,-3,-1,2,21202,-4,1,1,21102,1,384,0,1106,0,303,1106,0,415,21202,-4,-1,-4,22201,-4,-3,-4,22202,-3,-2,-2,22202,-2,-4,-4,22202,-3,-2,-3,21202,-4,-1,-2,22201,-3,-2,1,22101,0,1,-4,109,-5,2106,0,0`

const (
	w, h = 50, 50
)

var (
	codes = intcode.Parse(prog)
)

func main() {
	var data [][]byte
	for y := 0; y < h; y++ {
		data = append(data, make([]byte, w))
	}

	count := 0
	for y := 0; y < h; y++ {
		for x := 0; x < w; x++ {
			if evaluate(x, y) {
				data[y][x] = '#'
				count++
			} else {
				data[y][x] = '.'
			}
		}
	}
	termbox.RenderPlain(data, os.Stdout)
	fmt.Println(count)

	// Scan lines of slope -1 (x + y = K) looking for manhattan distance 200.
	for d := 1500; true; d++ {
		dist, val := scanSlope(d)
		if dist >= 200 {
			fmt.Println(val)
			break
		}
	}
}

func scanSlope(d int) (int, int) {
	x, y := 0, d
	var startX, startY int
	for {
		if evaluate(x, y) {
			startX, startY = x, y
			break
		}
		x++
		y--
	}
	for {
		if !evaluate(x, y) {
			break
		}
		x++
		y--
	}

	dist := (x - startX) + (startY - y)
	// Back up one
	x--
	y++
	return dist, startX*10000 + y
}

func evaluate(x, y int) bool {
	var ret int
	xy := 0
	m := intcode.NewIntMachine(codes, func() int {
		xy++
		switch xy {
		case 1:
			return x
		case 2:
			return y
		default:
			panic(xy)
		}
	}, func(v int) {
		ret = v
	})
	m.Run()
	return ret != 0
}
